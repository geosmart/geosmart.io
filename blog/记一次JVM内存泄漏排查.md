---
title: 记一次内存泄漏排查

date: 2017-08-03 20:41:50

tags: [JVM]

categories: 后端开发

---
## 内存泄漏排查案例
# 问题描述
* 一个hbase的rpc_server程序，运行后tcp长连接接收rpc client端的请求操作hbase数据库；
* 程序运行一段时间（3小时）后抛出java.lang.OutOfMemoryError:Java heap space；

## 解决方案
* `jps`命令定位程序进程：`jps -lvm | grep rpc`找到程序pid
* 服务端启动`jstatd`远程监控服务
* 客户端以`jvisualvm`工具连接jstatd端口，根据pid查看服务的运行情况；
* `jvisualvm`中安装visual gc插件，发现eden区每次回收后都有很多的survivor，survivor的1和2区交换几次满了后就都到old gen老年代去了，
导致每次回收后内存使用量一直在增长，内存使用曲线呈现45度锯齿状；
![内存使用曲线](https://user-images.githubusercontent.com/3156608/62417899-70777900-b68e-11e9-8eb7-37d367b316fb.png)
![GC可视化](https://user-images.githubusercontent.com/3156608/62417901-78cfb400-b68e-11e9-9ec4-3b6b141757ef.png)
毫无疑问是内存泄漏了！！！
* 程序添加OOM时输出日dump志，java程序启动命令新增：-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=/home/users/developer/service/log/mlp
* 下一次OOM发生后将生成的dump文件导入jvisualvm中分析；
* dump分析发现最多的是char[]，类实例中大多是insert语句语句中涉及的参数：清楚明白了，是数据库连接未释放
* 数据库连接是本地连接池管理的，所以基本不释放，但dao中生成的preparestatement和resultset需要手动释放；
* 在finally中添加statement.close方法释放资源；
* 重新运行程序，世界一片美好，回复了正常的非倾斜的锯齿状内存占用曲线；

# 关于内存泄漏
上面的内存泄漏问题问题是解决了，深入拓展开：
* 什么是内存泄漏？JVM内存管理、JVM垃圾回收方式；
* 内存泄漏的常见原因是什么？内存分配不足；代码bug；
* 不同情况的内存泄漏有什么表现特征？各种OOM情况；
* 如何定位解决内存泄漏问题？代码定位、工具定位；

# 什么是内存泄漏？
* Java使用new为对象分配内存，而这些内存空间都在堆（Heap）上;
* 一个对象是否是垃圾的依据：`引用计数法`，`可达性算法`实现;
* Java内存回收采用`分代回收算法`实现；
* Java的一个重要特性就是通过垃圾收集器(GC)自动管理内存的回收，而不需要程序员自己来释放内存。理论上Java中所有不会再被利用的对象所占用的内存，都可以被GC回收，但是Java也存在内存泄露，但它的表现与C++不同。
## Java中的内存管理
内存的释放，也即清理那些不可达的对象，是由GC决定和执行的，所以GC会监控每一个对象的状态，包括申请、引用、被引用和赋值等。`释放对象的根本原则就是对象不会再被使用`：
* 给对象赋予了空值null，之后再没有调用过。
* 另一个是给对象赋予了新值，这样重新分配了内存空间。

通常，会认为在堆上分配对象的代价比较大，但是GC却优化了这一操作：C++中，在堆上分配一块内存，会查找一块适用的内存加以分配，如果对象销毁，这块内存就可以重用；而Java中，就像一条长的带子，每分配一个新的对象，Java的“堆指针”就向后移动到尚未分配的区域。所以，Java分配内存的效率，可与C++媲美。

但是这种工作方式有一个问题：如果频繁的申请内存，资源将会耗尽。这时GC就介入了进来，它会回收空间，并使堆中的对象排列更紧凑。这样，就始终会有足够大的内存空间可以分配。
* gc清理时的引用计数方式：当引用连接至新对象时，引用计数+1；当某个引用离开作用域或被设置为null时，引用计数-1，GC发现这个计数为0时，就回收其占用的内存。这个开销会在引用程序的整个生命周期发生，并且不能处理`循环引用`的情况。所以这种方式只是用来说明GC的工作方式，而不会被任何一种Java虚拟机应用。
* 多数GC采用一种自适应的清理方式（加上其他附加的用于提升速度的技术），主要依据是找出任何“活”的对象，然后采用`自适应的、分代的、停止-复制、标记-清理`式的垃圾回收器。

# 内存泄漏的常见原因是什么？
Java中的内存泄露，广义并通俗的说，就是：`不再会被使用的对象的内存不能被回收，就是内存泄露`。
Java中的内存泄露与C++中的表现有所不同。
* 在C++中，所有被分配了内存的对象，不再使用后，都必须程序员手动的释放他们。所以，每个类，都会含有一个`析构函数`，作用就是完成清理工作，如果我们忘记了某些对象的释放，就会造成内存泄露。
* 但是在Java中，我们不用自己释放内存，无用的对象由GC自动清理，这也极大的简化了我们的编程工作。但，实际有时候一些不再会被使用的对象，在GC看来不能被释放，就会造成内存泄露。
我们知道，对象都是有生命周期的，有的长，有的短，
`如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露`。

## 常见的内存泄漏情况
* `监听器`：
* `静态集合类引起内存泄漏`：
* `各种连接：提供了close()方法的对象`：
* `单例模式导致的内存泄露`：
* `内部类和外部模块的引用`：
* `容器使用时的内存泄露`：

# 如何定位解决内存泄漏问题？

## 排查工具
内存泄漏排查过程中涉及到的工具：
* `jps`：查询进程
* `jvisualvm`、；综合监控：cpu、线程、内存、可视化gc
* `jstat`：jstat -gcutil查看jvm gc情况：jstat -gcutil 12743 1000 100
* `jmap`：导出堆转储文件：jmap -dump:live,format=b,file=20190803.dump pid
